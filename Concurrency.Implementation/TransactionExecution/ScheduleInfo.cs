using System.Collections.Generic;
using System.Diagnostics;
using Concurrency.Interface.Models;

namespace Concurrency.Implementation.TransactionExecution
{
    public class ScheduleInfo
    {
        public ScheduleInfo()
        {
            this.DeterministicNodes = new Dictionary<long, ScheduleNode>();
            this.LocalBidToRegionalBid = new Dictionary<long, long>();

            var node = new ScheduleNode(-1, true);
            node.NextNodeCanExecute.SetResult(true);

            this.DeterministicNodes.Add(-1, node);
            this.LocalBidToRegionalBid.Add(-1, -1);
        }

        public Dictionary<long, ScheduleNode> DeterministicNodes { get; init; }     // node ID: batch ID (local bid generated by local coordinators)

        public Dictionary<long, long> LocalBidToRegionalBid { get; init; }   // local bid, global bid

        public void InsertDeterministicBatch(SubBatch subBatch, long regionalBid, long highestCommittedBid)
        {
            ScheduleNode node;

            if (!this.DeterministicNodes.ContainsKey(subBatch.Bid))
            {
                node = new ScheduleNode(subBatch.Bid, true);
                this.DeterministicNodes.Add(subBatch.Bid, node);

                this.LocalBidToRegionalBid.Add(subBatch.Bid, regionalBid);
            }
            else node = this.DeterministicNodes[subBatch.Bid];

            if (this.DeterministicNodes.ContainsKey(subBatch.PreviousBid))
            {
                var prevNode = this.DeterministicNodes[subBatch.PreviousBid];
                if (prevNode.Next == null)
                {
                    prevNode.Next = node;
                    node.Previous = prevNode;
                }
                else
                {
                    Debug.Assert(prevNode.Next.IsDet == false && prevNode.Next.Next == null);
                    prevNode.Next.Next = node;
                    node.Previous = prevNode.Next;
                }
            }
            else
            {
                // last node is already deleted because it's committed
                if (highestCommittedBid >= subBatch.PreviousBid)
                {
                    var prevNode = this.DeterministicNodes[-1];
                    if (prevNode.Next == null)
                    {
                        prevNode.Next = node;
                        node.Previous = prevNode;
                    }
                    else
                    {
                        Debug.Assert(prevNode.Next.IsDet == false && prevNode.Next.Next == null);
                        prevNode.Next.Next = node;
                        node.Previous = prevNode.Next;
                    }
                }
                else   // last node hasn't arrived yet
                {
                    var prevNode = new ScheduleNode(subBatch.PreviousBid, true);
                    this.DeterministicNodes.Add(subBatch.PreviousBid, prevNode);
                    this.LocalBidToRegionalBid.Add(subBatch.PreviousBid, subBatch.lastGlobalBid);
                    prevNode.Next = node;
                    node.Previous = prevNode;
                    Debug.Assert(prevNode.Previous == null);
                }
            }
        }

        public ScheduleNode GetDependingNode(long bid)
        {
            return this.DeterministicNodes[bid].Previous;
        }

        public void CompleteDeterministicBatch(long bid)
        {
            this.DeterministicNodes[bid].NextNodeCanExecute.SetResult(true);
        }
    }

}